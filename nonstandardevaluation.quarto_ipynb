{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Non-Standard Evaluation in R with rlang\"\n",
        "author: \"Your Name\"\n",
        "date: \"2023-11-14\"\n",
        "format:\n",
        " html:\n",
        "    code-fold: show\n",
        "    code-tools: true\n",
        "    code-overflow: wrap\n",
        "    code-block-bg: \"#f1f3f5\"\n",
        "    code-block-border-left: \"#31BAE9\"\n",
        "    highlight-style: github\n",
        "execute:\n",
        "  eval: false\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "# Non-Standard Evaluation in R with `rlang`\n",
        "\n",
        "## Introduction\n",
        "\n",
        "Non-standard evaluation (NSE) is a powerful feature in R that allows you to manipulate code expressions instead of just their evaluated values. This is particularly useful when writing functions that interact with variable names or expressions, such as data manipulation functions in the tidyverse. The `rlang` package provides modern tools for NSE, commonly referred to as **tidy evaluation**, which make writing such functions safer and more intuitive.\n",
        "\n",
        "This document explains non-standard evaluation in R, focusing on the `rlang` package and its applications within the tidyverse ecosystem.\n",
        "\n",
        "---\n",
        "\n",
        "## Table of Contents\n",
        "1. [Understanding Non-Standard Evaluation](#understanding-non-standard-evaluation)\n",
        "2. [Limitations of Base R NSE Functions](#limitations-of-base-r-nse-functions)\n",
        "3. [Tidy Evaluation with `rlang`](#tidy-evaluation-with-rlang)\n",
        "    - [Capturing Symbols and Expressions](#capturing-symbols-and-expressions)\n",
        "    - [Unquoting and Injecting Expressions](#unquoting-and-injecting-expressions)\n",
        "    - [The Curly-Curly `{{ }}` Operator](#the-curly-curly--operator)\n",
        "4. [Practical Examples](#practical-examples)\n",
        "    - [Writing Functions with Tidy Evaluation](#writing-functions-with-tidy-evaluation)\n",
        "    - [Handling Strings and Symbols Flexibly](#handling-strings-and-symbols-flexibly)\n",
        "5. [Key Takeaways](#key-takeaways)\n",
        "6. [Conclusion](#conclusion)\n",
        "\n",
        "---\n",
        "\n",
        "\n",
        "## Understanding Non-Standard Evaluation\n",
        "\n",
        "In **standard evaluation**, function arguments are evaluated in the environment where the function is called before being passed to the function.\n",
        "\n",
        "\n",
        "```{r}\n",
        "x <- 10\n",
        "standard_eval_example <- function(arg) {\n",
        "  print(arg)\n",
        "}\n",
        "\n",
        "standard_eval_example(x)\n",
        "# Output: 10\n",
        "```\n",
        "\n",
        "    summarize(count = n())\n",
        "}\n",
        "\n",
        "# Using the function directly works as expected\n",
        "summarize_by(mtcars, cyl)\n",
        "```\n",
        "\n",
        "**Now, you want to call `summarize_by()` from within another function:**\n",
        "\n",
        "```r\n",
        "first_function <- function(data, group_col) {\n",
        "  summarize_by(data, group_col)\n",
        "}\n",
        "\n",
        "# Attempting to use the function\n",
        "first_function(mtcars, cyl)\n",
        "```\n",
        "\n",
        "**Issue:**\n",
        "\n",
        "When you run `first_function(mtcars, cyl)`, you may encounter an error or unexpected behavior. This happens because the NSE mechanics in `summarize_by()` are trying to capture `group_col` from the environment of `summarize_by()`, not from the original caller.\n",
        "\n",
        "**Solution:**\n",
        "\n",
        "To correctly pass NSE arguments through multiple function calls, you need to explicitly capture and forward the expressions using `enquo()` and the unquoting operator `!!`.\n",
        "\n",
        "**Corrected Code:**\n",
        "\n",
        "```r\n",
        "library(dplyr)\n",
        "\n",
        "# The original function using NSE\n",
        "summarize_by <- function(data, group_col) {\n",
        "  data %>%\n",
        "    group_by({{ group_col }}) %>%\n",
        "    summarize(count = n())\n",
        "}\n",
        "\n",
        "# The wrapper function that properly handles NSE argument\n",
        "first_function <- function(data, group_col) {\n",
        "  # Capture the expression as a quosure\n",
        "  group_col_quo <- enquo(group_col)\n",
        "  # Pass the quosure to the inner function using unquoting\n",
        "  summarize_by(data, !!group_col_quo)\n",
        "}\n",
        "\n",
        "# Using the function now works as expected\n",
        "first_function(mtcars, cyl)\n",
        "```\n",
        "\n",
        "**Explanation:**\n",
        "\n",
        "- **`enquo(group_col)`**: Captures the `group_col` argument as a **quosure**, which includes both the expression and its environment.\n",
        "- **`!!group_col_quo`**: Unquotes the quosure when passing it to `summarize_by()`, ensuring that the original expression is evaluated in the correct context.\n",
        "\n",
        "**Why This Works:**\n",
        "\n",
        "- The `enquo()` function captures the argument provided to `first_function()` without evaluating it.\n",
        "- By unquoting `!!group_col_quo` when calling `summarize_by()`, you effectively pass the captured expression so that `summarize_by()` can evaluate it properly with its NSE mechanics.\n",
        "\n",
        "**Alternative with `...`:**\n",
        "\n",
        "If you want to pass multiple NSE arguments or make your functions more flexible, you can use the `...` (ellipsis) to pass arguments along.\n",
        "\n",
        "**Example:**\n",
        "\n",
        "```r\n",
        "summarize_by <- function(data, ...) {\n",
        "  data %>%\n",
        "    group_by(...) %>%\n",
        "    summarize(count = n())\n",
        "}\n",
        "\n",
        "first_function <- function(data, ...) {\n",
        "  summarize_by(data, ...)\n",
        "}\n",
        "\n",
        "# Using the function with multiple grouping variables\n",
        "first_function(mtcars, cyl, gear)\n",
        "```\n",
        "\n",
        "**Note:**\n",
        "\n",
        "- When using `...`, you can pass any number of NSE arguments, and they will be correctly handled by the inner function.\n",
        "- This approach is suitable when you don't need to manipulate the NSE arguments inside the wrapper function.\n",
        "\n",
        "---\n",
        "\n",
        "**Practical Guidelines for Passing NSE Arguments:**\n",
        "\n",
        "1. **Capture NSE Arguments with `enquo()` or `enquos()`:**\n",
        "\n",
        "   - Use `enquo()` for a single argument.\n",
        "   - Use `enquos()` for multiple arguments.\n",
        "\n",
        "   ```r\n",
        "   first_function <- function(data, group_col) {\n",
        "     group_col_quo <- enquo(group_col)\n",
        "     # ...\n",
        "   }\n",
        "   ```\n",
        "\n",
        "2. **Forward Captured Quosures with Unquoting `!!` or Splicing `!!!`:**\n",
        "\n",
        "   - Use `!!` to unquote a single quosure.\n",
        "   - Use `!!!` to splice a list of quosures.\n",
        "\n",
        "   ```r\n",
        "   summarize_by(data, !!group_col_quo)\n",
        "   ```\n",
        "\n",
        "3. **Use `{{ }}` in the Innermost Function Only:**\n",
        "\n",
        "   - The `{{ }}` operator is syntactic sugar for capturing and unquoting in a single step.\n",
        "   - It works best when used directly within the function where the NSE argument originates.\n",
        "   - When wrapping such functions, prefer explicit capturing and unquoting.\n",
        "\n",
        "4. **Be Mindful of Environments:**\n",
        "\n",
        "   - Quosures capture the environment, ensuring that variables are evaluated in the correct context.\n",
        "   - This is crucial when NSE functions are nested within other functions.\n",
        "\n",
        "---\n",
        "\n",
        "**Complete Example in the Document:**\n",
        "\n",
        "```r\n",
        "library(dplyr)\n",
        "\n",
        "# Inner function using NSE with {{ }}\n",
        "summarize_by <- function(data, group_col) {\n",
        "  data %>%\n",
        "    group_by({{ group_col }}) %>%\n",
        "    summarize(count = n())\n",
        "}\n",
        "\n",
        "# Wrapper function that properly handles NSE arguments\n",
        "first_function <- function(data, group_col) {\n",
        "  # Capture the NSE argument as a quosure\n",
        "  group_col_quo <- enquo(group_col)\n",
        "  # Pass it to the inner function using unquoting\n",
        "  summarize_by(data, !!group_col_quo)\n",
        "}\n",
        "\n",
        "# Using the function\n",
        "result <- first_function(mtcars, cyl)\n",
        "print(result)\n",
        "```\n",
        "\n",
        "**Output:**\n",
        "\n",
        "```\n",
        "# A tibble: 3 × 2\n",
        "    cyl count\n",
        "  <dbl> <int>\n",
        "1     4    11\n",
        "2     6     7\n",
        "3     8    14\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "**Explanation in the Context of the Document:**\n",
        "\n",
        "### Handling NSE in Nested Function Calls\n",
        "\n",
        "When you have functions that use tidy evaluation and you want to call them from within other functions, it's important to manage the NSE arguments properly. Here’s how you can do it:\n",
        "\n",
        "1. **Capture the Argument in the Outer Function:**\n",
        "\n",
        "   Use `enquo()` in the outer function to capture the NSE argument as a quosure.\n",
        "\n",
        "   ```r\n",
        "   first_function <- function(data, group_col) {\n",
        "     group_col_quo <- enquo(group_col)\n",
        "     # ...\n",
        "   }\n",
        "   ```\n",
        "\n",
        "2. **Unquote the Argument in the Inner Function Call:**\n",
        "\n",
        "   When calling the inner function, unquote the quosure using `!!` so that the inner function receives the correct expression.\n",
        "\n",
        "   ```r\n",
        "   summarize_by(data, !!group_col_quo)\n",
        "   ```\n",
        "\n",
        "3. **Use `{{ }}` in the Inner Function:**\n",
        "\n",
        "   The inner function can use `{{ }}` to simplify the NSE handling.\n",
        "\n",
        "   ```r\n",
        "   summarize_by <- function(data, group_col) {\n",
        "     data %>%\n",
        "       group_by({{ group_col }}) %>%\n",
        "       summarize(count = n())\n",
        "   }\n",
        "   ```\n",
        "\n",
        "**Key Points:**\n",
        "\n",
        "- **Quosures**: Quosures are expressions that carry their environment, allowing them to be evaluated correctly later on.\n",
        "- **Capturing vs. Evaluating**: By capturing the argument in the outer function and unquoting it in the inner function, you maintain the correct evaluation context.\n",
        "- **Avoid Double Evaluation**: Properly managing the NSE arguments prevents them from being accidentally evaluated too early or too late.\n",
        "\n",
        "---\n",
        "\n",
        "**Alternative Approach Using `enquos()` and `!!!`:**\n",
        "\n",
        "If your inner function accepts multiple NSE arguments, you can use `enquos()` and the splicing operator `!!!`.\n",
        "\n",
        "**Example:**\n",
        "\n",
        "```r\n",
        "library(dplyr)\n",
        "\n",
        "# Inner function that groups by multiple columns\n",
        "summarize_by <- function(data, ...) {\n",
        "  data %>%\n",
        "    group_by(...) %>%\n",
        "    summarize(count = n())\n",
        "}\n",
        "\n",
        "# Wrapper function that captures multiple NSE arguments\n",
        "first_function <- function(data, ...) {\n",
        "  group_cols_quos <- enquos(...)\n",
        "  summarize_by(data, !!!group_cols_quos)\n",
        "}\n",
        "\n",
        "# Using the function with multiple grouping columns\n",
        "result <- first_function(mtcars, cyl, gear)\n",
        "print(result)\n",
        "```\n",
        "\n",
        "**Output:**\n",
        "\n",
        "```\n",
        "# A tibble: 6 × 3\n",
        "    cyl  gear count\n",
        "  <dbl> <dbl> <int>\n",
        "1     4     3     1\n",
        "2     4     4     8\n",
        "3     4     5     2\n",
        "4     6     3     2\n",
        "5     6     4     4\n",
        "6     8     3    13\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "**Conclusion:**\n",
        "\n",
        "When dealing with NSE and nested function calls in R, it's crucial to:\n",
        "\n",
        "- Properly capture NSE arguments using `enquo()` or `enquos()`.\n",
        "- Forward these arguments using unquoting (`!!`) or splicing (`!!!`).\n",
        "- Understand that `{{ }}` is a convenient shortcut for simple cases but may require explicit handling in more complex scenarios.\n",
        "\n",
        "By following these practices, you ensure that your functions behave as expected, making your code robust and reliable.\n",
        "\n",
        "---\n",
        "\n",
        "**Updated Table of Contents:**\n",
        "\n",
        "1. [Understanding Non-Standard Evaluation](#understanding-non-standard-evaluation)\n",
        "2. [Limitations of Base R NSE Functions](#limitations-of-base-r-nse-functions)\n",
        "3. [Tidy Evaluation with `rlang`](#tidy-evaluation-with-rlang)\n",
        "    - [Capturing Symbols and Expressions](#capturing-symbols-and-expressions)\n",
        "    - [Unquoting and Injecting Expressions](#unquoting-and-injecting-expressions)\n",
        "    - [The Curly-Curly `{{ }}` Operator](#the-curly-curly--operator)\n",
        "4. [Practical Examples](#practical-examples)\n",
        "    - [Writing Functions with Tidy Evaluation](#writing-functions-with-tidy-evaluation)\n",
        "    - [Handling Strings and Symbols Flexibly](#handling-strings-and-symbols-flexibly)\n",
        "    - [Calling Functions that Use NSE from Within Other Functions](#calling-functions-that-use-nse-from-within-other-functions)\n",
        "5. [Key Takeaways](#key-takeaways)\n",
        "6. [Conclusion](#conclusion)\n",
        "\n",
        "---\n",
        "\n",
        "Feel free to include this explanation in your document to provide a comprehensive guide on how to handle non-standard evaluation in R, especially when dealing with nested function calls within the tidyverse ecosystem.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Handling `tar_read()` and Non-Standard Evaluation in Functions\n",
        "\n",
        "When working with the `targets` package in R, you might encounter situations where you want your functions to accept either the name of a target (as a symbol or character string) to be read using `tar_read()`, or a data frame directly. This flexibility is particularly useful for testing purposes, allowing you to pass data frames directly without running the entire pipeline.\n",
        "\n",
        "However, because `tar_read()` uses non-standard evaluation (NSE) to interpret the target name, you may need to handle NSE carefully in your functions. In this section, we'll explore how `tar_read()` works, how it utilizes NSE, and how to write functions that can flexibly handle both cases.\n",
        "\n",
        "---\n",
        "\n",
        "### Understanding `tar_read()` and Non-Standard Evaluation\n",
        "\n",
        "The `tar_read()` function from the `targets` package is designed to read a target from your pipeline. You can specify the target to read either as an unquoted symbol or as a character string. Internally, `tar_read()` uses NSE to capture the expression provided and resolve it to the name of the target.\n",
        "\n",
        "**Examples of `tar_read()` Usage:**\n",
        "\n",
        "```r\n",
        "library(targets)\n",
        "\n",
        "# Assuming you have a target named 'my_data' in your pipeline\n",
        "\n",
        "# Using an unquoted symbol\n",
        "data <- tar_read(my_data)\n",
        "\n",
        "# Using a character string\n",
        "data <- tar_read(\"my_data\")\n",
        "```\n",
        "\n",
        "- In the first example, `my_data` is an unquoted symbol. `tar_read()` uses NSE to capture this symbol and determine the target to read.\n",
        "- In the second example, `\"my_data\"` is a character string specifying the target name directly.\n",
        "\n",
        "---\n",
        "\n",
        "### Writing Functions That Accept Either Target Names or Data Frames\n",
        "\n",
        "To create functions that can accept either a target name (to be read with `tar_read()`) or a data frame directly, you need to handle both cases within your function. One approach is to check the type of the input and act accordingly.\n",
        "\n",
        "**Example Function Handling Both Cases:**\n",
        "\n",
        "```r\n",
        "library(targets)\n",
        "library(dplyr)\n",
        "\n",
        "process_data <- function(data) {\n",
        "  if (is.character(data)) {\n",
        "    # 'data' is a character string specifying the target name\n",
        "    data <- tar_read(data)\n",
        "  } else if (is.symbol(substitute(data))) {\n",
        "    # 'data' is an unquoted symbol (target name)\n",
        "    data_name <- deparse(substitute(data))\n",
        "    data <- tar_read(data_name)\n",
        "  }\n",
        "  # Proceed with data processing\n",
        "  result <- data %>%\n",
        "    summarize(count = n())\n",
        "  \n",
        "  return(result)\n",
        "}\n",
        "\n",
        "# Usage with unquoted target name\n",
        "output <- process_data(my_data)\n",
        "\n",
        "# Usage with quoted target name (character string)\n",
        "output <- process_data(\"my_data\")\n",
        "\n",
        "# Usage with a data frame directly (e.g., for testing)\n",
        "test_data <- data.frame(x = 1:10)\n",
        "output <- process_data(test_data)\n",
        "```\n",
        "\n",
        "**Explanation:**\n",
        "\n",
        "- **Unquoted Target Name (Symbol):**\n",
        "  - We use `substitute(data)` to capture the expression passed to `data`.\n",
        "  - If it's a symbol (unquoted target name), we convert it to a string with `deparse(substitute(data))` and pass it to `tar_read()`.\n",
        "\n",
        "- **Character String Target Name:**\n",
        "  - If `data` is a character string, we pass it directly to `tar_read()`.\n",
        "\n",
        "- **Data Frame Directly:**\n",
        "  - If `data` is neither a character string nor a symbol, we assume it's a data frame and proceed with processing.\n",
        "\n",
        "---\n",
        "\n",
        "### Handling NSE with `rlang`\n",
        "\n",
        "Alternatively, you can use the `rlang` package to handle NSE more robustly.\n",
        "\n",
        "**Using `rlang` to Manage NSE:**\n",
        "\n",
        "```r\n",
        "library(targets)\n",
        "library(dplyr)\n",
        "library(rlang)\n",
        "\n",
        "process_data <- function(data) {\n",
        "  data_expr <- enquo(data)\n",
        "  \n",
        "  if (quo_is_symbol(data_expr)) {\n",
        "    # 'data' is an unquoted symbol (target name)\n",
        "    data_name <- as_name(data_expr)\n",
        "    data <- tar_read(data_name)\n",
        "  } else if (quo_is_string(data_expr)) {\n",
        "    # 'data' is a character string\n",
        "    data_name <- eval_tidy(data_expr)\n",
        "    data <- tar_read(data_name)\n",
        "  } else if (quo_is_call(data_expr)) {\n",
        "    # 'data' is evaluated as an expression (e.g., data frame variable)\n",
        "    data <- eval_tidy(data_expr)\n",
        "  } else {\n",
        "    stop(\"Invalid input: please provide a data frame or a target name.\")\n",
        "  }\n",
        "  \n",
        "  # Proceed with data processing\n",
        "  result <- data %>%\n",
        "    summarize(count = n())\n",
        "  \n",
        "  return(result)\n",
        "}\n",
        "\n",
        "# Usage with unquoted target name\n",
        "output <- process_data(my_data)\n",
        "\n",
        "# Usage with quoted target name (character string)\n",
        "output <- process_data(\"my_data\")\n",
        "\n",
        "# Usage with a data frame directly\n",
        "test_data <- data.frame(x = 1:10)\n",
        "output <- process_data(test_data)\n",
        "```\n",
        "\n",
        "**Explanation:**\n",
        "\n",
        "- **`enquo(data)`:**\n",
        "  - Captures the argument passed to `data` as a quosure, which contains both the expression and its environment.\n",
        "\n",
        "- **Interpreting `data`:**\n",
        "  - **If `data` is a symbol (unquoted target name):**\n",
        "    - Use `quo_is_symbol()` to check.\n",
        "    - Convert to string with `as_name()` and read using `tar_read()`.\n",
        "  - **If `data` is a string:**\n",
        "    - Use `quo_is_string()` to check.\n",
        "    - Evaluate the string and pass to `tar_read()`.\n",
        "  - **If `data` is a call or expression:**\n",
        "    - Use `quo_is_call()` to check.\n",
        "    - Evaluate the expression with `eval_tidy()`.\n",
        "\n",
        "- **Data Frame Handling:**\n",
        "  - If `data` evaluates to a data frame, proceed with processing.\n",
        "  - If `data` is invalid, throw an error.\n",
        "\n",
        "---\n",
        "\n",
        "### Practical Example\n",
        "\n",
        "**Suppose you have the following target pipeline in `_targets.R`:**\n",
        "\n",
        "```r\n",
        "library(targets)\n",
        "\n",
        "tar_option_set(packages = c(\"dplyr\"))\n",
        "\n",
        "list(\n",
        "  tar_target(\n",
        "    my_data,\n",
        "    data.frame(x = rnorm(100), y = rnorm(100))\n",
        "  ),\n",
        "  tar_target(\n",
        "    result,\n",
        "    process_data(my_data)\n",
        "  )\n",
        ")\n",
        "```\n",
        "\n",
        "- **`my_data`**: A target that creates a data frame.\n",
        "- **`result`**: A target that processes `my_data` using `process_data()`.\n",
        "\n",
        "**In your `functions.R` file:**\n",
        "\n",
        "```r\n",
        "process_data <- function(data) {\n",
        "  # Function as defined earlier\n",
        "  # ...\n",
        "}\n",
        "```\n",
        "\n",
        "**Testing the Function Directly:**\n",
        "\n",
        "```r\n",
        "# Load the functions\n",
        "source(\"functions.R\")\n",
        "\n",
        "# Test with a data frame\n",
        "test_df <- data.frame(x = 1:10)\n",
        "process_data(test_df)\n",
        "\n",
        "# Test with a character string target name\n",
        "process_data(\"my_data\")\n",
        "\n",
        "# Test with an unquoted target name (assuming `my_data` exists in the environment)\n",
        "process_data(my_data)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "### Additional Considerations\n",
        "\n",
        "- **Avoid Ambiguity with Explicit Arguments:**\n",
        "  - To prevent confusion, you might choose to require that target names be provided as character strings.\n",
        "  - Alternatively, you could have separate arguments or functions for handling data frames and target names.\n",
        "\n",
        "- **Documentation and User Guidance:**\n",
        "  - Clearly document how users should provide the `data` argument.\n",
        "  - Explain the expected input types and any constraints.\n",
        "\n",
        "- **Error Handling:**\n",
        "  - Implement robust error handling to provide informative messages.\n",
        "  - Use `is.data.frame()` to check if `data` is a data frame after evaluation.\n",
        "\n",
        "---\n",
        "\n",
        "### Simplifying with Separate Functions\n",
        "\n",
        "If managing NSE becomes too complex, consider separating the functionality:\n",
        "\n",
        "- **Function for Data Frames:**\n",
        "\n",
        "  ```r\n",
        "  process_data_df <- function(data) {\n",
        "    data %>%\n",
        "      summarize(count = n())\n",
        "  }\n",
        "  ```\n",
        "\n",
        "- **Function for Target Names:**\n",
        "\n",
        "  ```r\n",
        "  process_data_target <- function(target_name) {\n",
        "    data <- tar_read(target_name)\n",
        "    process_data_df(data)\n",
        "  }\n",
        "  ```\n",
        "\n",
        "- **Usage:**\n",
        "\n",
        "  ```r\n",
        "  # For data frames\n",
        "  result <- process_data_df(test_data)\n",
        "\n",
        "  # For target names\n",
        "  result <- process_data_target(\"my_data\")\n",
        "  ```\n",
        "\n",
        "This approach simplifies each function and makes the expected input explicit.\n",
        "\n",
        "---\n",
        "\n",
        "### Conclusion\n",
        "\n",
        "Handling non-standard evaluation and functions like `tar_read()` requires careful consideration, especially when designing flexible functions. By using functions like `substitute()`, `enquo()`, and tools from the `rlang` package, you can create functions that accept both unquoted target names, character strings, and data frames.\n",
        "\n",
        "Key points:\n",
        "\n",
        "- **Understand how `tar_read()` handles NSE**: It can accept both symbols and character strings.\n",
        "- **Use `enquo()` and `rlang` functions to manage NSE in your own functions**.\n",
        "- **Provide clear documentation and error handling** to guide users in providing the correct inputs.\n",
        "- **Consider separating functionality** if the NSE handling becomes too complex.\n",
        "\n",
        "By applying these strategies, you can build robust data processing functions that integrate smoothly with the `targets` package and provide flexibility for both pipeline execution and testing.\n",
        "\n",
        "---\n",
        "\n",
        "**References:**\n",
        "\n",
        "- [targets Package Documentation](https://books.ropensci.org/targets/)\n",
        "- [Non-Standard Evaluation in R](https://adv-r.hadley.nz/evaluation.html)\n",
        "- [rlang Package Documentation](https://rlang.r-lib.org/)\n",
        "By applying these strategies, you can build robust data processing functions that integrate smoothly with the `targets` package and provide flexibility for both pipeline execution and testing.\n",
        "\n",
        "---\n",
        "\n",
        "**References:**\n",
        "\n",
        "- [targets Package Documentation](https://books.ropensci.org/targets/)\n",
        "- [Non-Standard Evaluation in R](https://adv-r.hadley.nz/evaluation.html)\n",
        "- [rlang Package Documentation](https://rlang.r-lib.org/)"
      ],
      "id": "69659d12"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3",
      "path": "/Users/harlananelson/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}